---
interface Props {
	/**
	 * 目次を生成する対象のセレクター
	 * デフォルト: '.prose'
	 */
	selector?: string;
	/**
	 * 目次のタイトル
	 * デフォルト: '目次'
	 */
	title?: string;
}

const { selector = '.prose', title = '目次' } = Astro.props;
const tocId = `toc-${Math.random().toString(36).substr(2, 9)}`;
const tocListId = `toc-list-${Math.random().toString(36).substr(2, 9)}`;
---

<nav class="table-of-contents" id={tocId}>
	<h3 class="toc-title">{title}</h3>
	<ul class="toc-list" id={tocListId}></ul>
</nav>

<script is:inline define:vars={{ selector, tocId, tocListId }}>
	document.addEventListener('DOMContentLoaded', () => {
		// 目次生成
		const headings = document.querySelectorAll(`${selector} h2, ${selector} h3, ${selector} h4`);
		const tocList = document.getElementById(tocListId);
		const toc = document.getElementById(tocId);
		
		if (headings.length > 0 && tocList && toc) {
			headings.forEach((heading, index) => {
				const id = `heading-${index}`;
				heading.id = id;
				
				const level = parseInt(heading.tagName.charAt(1));
				const text = heading.textContent || '';
				
				const li = document.createElement('li');
				li.className = `toc-item toc-level-${level}`;
				
				const a = document.createElement('a');
				a.href = `#${id}`;
				a.textContent = text;
				a.className = 'toc-link';
				
				li.appendChild(a);
				tocList.appendChild(li);
				
				// スムーズスクロール（ヘッダーの高さを考慮）
				a.addEventListener('click', (e) => {
					e.preventDefault();
					
					// ヘッダーの高さを取得
					const header = document.querySelector('header');
					const headerHeight = header ? header.offsetHeight : 0;
					
					// 見出しの位置を取得
					const headingRect = heading.getBoundingClientRect();
					const headingTop = headingRect.top + window.pageYOffset;
					
					// ヘッダーの高さ分だけオフセットを追加（少し余白も追加）
					const offset = headerHeight + 20;
					const targetPosition = headingTop - offset;
					
					// スムーズスクロール
					window.scrollTo({
						top: targetPosition,
						behavior: 'smooth'
					});
					
					// URLを更新
					window.history.pushState(null, '', `#${id}`);
				});
			});
			
			// アクティブな見出しをハイライト（ヘッダーの高さを考慮）
			const header = document.querySelector('header');
			const headerHeight = header ? header.offsetHeight : 0;
			// ヘッダーの下に見出しが来たときにアクティブになるように、rootMarginを調整
			// ヘッダーの高さ + 少し余白（20px）を上側のマージンに設定
			const topMargin = headerHeight + 20;
			const observerOptions = {
				root: null,
				rootMargin: `-${topMargin}px 0px -70% 0px`,
				threshold: 0
			};
			
			const tocContainer = document.querySelector(`#${tocId}`);
			
			const observer = new IntersectionObserver((entries) => {
				// 複数の見出しが交差している場合、最初に見つかったもの（上から順）をアクティブにする
				const intersectingEntries = entries.filter(entry => entry.isIntersecting);
				if (intersectingEntries.length === 0) return;
				
				// 最も上にある見出しを取得
				let topmostEntry = intersectingEntries[0];
				for (const entry of intersectingEntries) {
					if (entry.boundingClientRect.top < topmostEntry.boundingClientRect.top) {
						topmostEntry = entry;
					}
				}
				
				const id = topmostEntry.target.id;
				const activeLink = tocList.querySelector(`a[href="#${id}"]`);
				if (activeLink) {
					tocList.querySelectorAll('.toc-link').forEach(link => {
						link.classList.remove('active');
					});
					activeLink.classList.add('active');
					
					// アクティブな目次項目が常に表示されるようにスクロール位置を調整
					if (tocContainer) {
						const containerRect = tocContainer.getBoundingClientRect();
						const linkRect = activeLink.getBoundingClientRect();
						const containerTop = containerRect.top;
						const containerBottom = containerRect.bottom;
						const linkTop = linkRect.top;
						const linkBottom = linkRect.bottom;
						const containerHeight = containerRect.height;
						
						// アクティブな項目がコンテナの上に出ている場合
						if (linkTop < containerTop) {
							const currentScroll = tocContainer.scrollTop;
							const linkOffsetTop = activeLink.offsetTop;
							const newScrollTop = linkOffsetTop - 20; // 少し余白を追加
							tocContainer.scrollTo({ top: newScrollTop, behavior: 'smooth' });
						}
						// アクティブな項目がコンテナの下に出ている場合
						else if (linkBottom > containerBottom) {
							const currentScroll = tocContainer.scrollTop;
							const linkOffsetTop = activeLink.offsetTop;
							const linkHeight = activeLink.offsetHeight;
							const newScrollTop = linkOffsetTop + linkHeight - containerHeight + 20; // 少し余白を追加
							tocContainer.scrollTo({ top: newScrollTop, behavior: 'smooth' });
						}
					}
				}
			}, observerOptions);
			
			headings.forEach(heading => observer.observe(heading));
		} else if (toc) {
			// 見出しがない場合は目次を非表示
			toc.style.display = 'none';
		}
	});
</script>

